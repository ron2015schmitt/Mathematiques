[1mdiff --git a/include/grids.h b/include/grids.h[m
[1mindex ee1f8fb2..b8abc31c 100644[m
[1m--- a/include/grids.h[m
[1m+++ b/include/grids.h[m
[36m@@ -5,6 +5,21 @@[m
 namespace mathq {[m
 [m
 [m
[32m+[m[32m  // ***************************************************************************[m
[32m+[m[32m  //  IsDomain<T>[m
[32m+[m[32m  //[m
[32m+[m[32m  // ***************************************************************************[m
[32m+[m
[32m+[m[32m  template <typename GridElement>[m
[32m+[m[32m  bool is_domain_test(Domain<GridElement>& x) {[m
[32m+[m[32m    return true;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  template <class T>[m
[32m+[m[32m  concept IsDomain = requires(T x) {[m
[32m+[m[32m    is_domain_test(x);[m
[32m+[m[32m  };[m
[32m+[m
 [m
   template <typename GridElement, size_t Ndims, bool TimeCoord, class Derived, size_t... dim_ints>[m
   class CurvilinearCoords;[m
[36m@@ -133,6 +148,28 @@[m [mnamespace mathq {[m
         Vector<GridElement>& grid = *(new Vector<GridElement>);[m
         return grid;[m
       }[m
[32m+[m
[32m+[m
[32m+[m[32m      virtual inline std::string classname() const {[m
[32m+[m[32m        return *(new std::string);[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m[32m      static inline std::string ClassName() {[m
[32m+[m[32m        using namespace display;[m
[32m+[m[32m        std::string s = "Domain";[m
[32m+[m[32m        s += StyledString::get(ANGLE1).get();[m
[32m+[m[32m        GridElement d;[m
[32m+[m[32m        s += getTypeName(d);[m
[32m+[m[32m        s += StyledString::get(ANGLE2).get();[m
[32m+[m[32m        return s;[m
[32m+[m[32m      }[m
[32m+[m
[32m+[m
[32m+[m[32m      inline friend std::ostream& operator<<(std::ostream& stream, const Domain& var) {[m
[32m+[m[32m        using namespace display;[m
[32m+[m[32m        return stream;[m
[32m+[m[32m      }[m
[32m+[m
   };[m
 [m
 [m
[36m@@ -166,6 +203,7 @@[m [mnamespace mathq {[m
         Matrix<SimpleNumberType>& grid = *(new Matrix<SimpleNumberType>);[m
         return grid;[m
       }[m
[32m+[m
   };[m
 [m
 [m
[36m@@ -975,7 +1013,7 @@[m [mnamespace mathq {[m
     using ElementType = CoordGrid<GridElement, total_num_dims, dim_ints...>;[m
     using NumberType = GridElement;[m
     using SimpleNumberType = typename SimpleNumberTrait<GridElement>::Type;[m
[31m-    using DomainType = Interval<GridElement>;[m
[32m+[m[32m    using DomainType = Domain<GridElement>;[m
     using GridType = ElementType;[m
 [m
     using TypeWithTime = CurvilinearCoords<GridElement, Ndims, true, Derived, dim_ints...>;[m
[36m@@ -1003,7 +1041,10 @@[m [mnamespace mathq {[m
       setup_vector_indices();[m
     }[m
 [m
[31m-    CurvilinearCoords(const std::initializer_list<DomainType>& mylist) : ParentType() {[m
[32m+[m[32m    // template <typename T> requires (IsDomain<T>)[m
[32m+[m[32m    CurvilinearCoords(const std::initializer_list<Interval<GridElement>>& mylist) : ParentType() {[m
[32m+[m[32m      // TRDISP(mylist);[m
[32m+[m[32m      // return;[m
       setup_vector_indices();[m
       *this = mylist;[m
     }[m
[36m@@ -1203,7 +1244,7 @@[m [mnamespace mathq {[m
   // * CartesianCoords<GridElement, Ndims>[m
   // ***************************************************************************[m
 [m
[31m-// TODO: need a way include optinal time coordinate, perhaps template bool[m
[32m+[m[32m  // TODO: need a way include optinal time coordinate, perhaps template bool[m
 [m
 [m
   template <class GridElement, size_t Ndims, bool TimeCoord>[m
