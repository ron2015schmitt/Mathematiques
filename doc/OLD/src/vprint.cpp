


#include "mathq.h"

#include <iostream>
#include <string>

// used to demonstrate how to convert to C++ vectors
#include <vector>



// ************************************************************
// The output screenshots are generated by examples/printing.cpp
// ************************************************************


int main()
{
  using namespace mathq;
  using namespace std;
  using namespace display;
  

  int Nex = 1;
  
  mathq_toc();
  CR();CR();
  GMD_TITLE("\\*Formatted and styled printing");
  mathq_preamble();
  OUTPUT("* The examples in this section can be found in file_ `examples/printing.cpp`\n");
  OUTPUT("* All of the functions decribed in this section are in the namespace `display`");
  OUTPUT("* Practically speaking, this functionality is one of the most useful aspects of Math√©matiques.");


  // DISP()
  
  GMD_HEADER2("The function `DISP(x)`");
  CR();CR();

  OUTPUT("The function `DISP(x)` displays both the variable name (or expression) as well as its value, formatted according to the user.   This is an incredibly useful function.");
  CR();CR();
  
  EXAMPLE(Nex++,"simple examples of `DISP(x)` usage");
  CR();CR();
  OUTPUT("Define and initialize some variables:");
  CR();CR();
  GMD_CODE_START("C++");
  ECHO_CODE(  int n = 45 );
  ECHO_CODE(  int m =256 );
  ECHO_CODE(  double x = 3.14 );
  ECHO_CODE(  double vals[] = {1.1,2.2,3.3} );
  ECHO_CODE(  bool done = true );
  ECHO_CODE( Vector<double> v = range<double>(1,10) );
  ECHO_CODE(  char str[] = "hello" );
  ECHO_CODE(  std::string s = "world"  );
  ECHO_CODE(  ComplexDouble z(1,-1)  );
  GMD_CODE_END();

  OUTPUT("display each variable using `disp`:");
  CR();CR();

  GMD_CODE_START("C++");
  OUTPUT("DISP(n);");
  OUTPUT("DISP(m);");
  OUTPUT("DISP(x);");
  OUTPUT("DISP(vals);");
  OUTPUT("DISP(done);");
  OUTPUT("DISP(v);");
  OUTPUT("DISP(str);");
  OUTPUT("DISP(s);");
  OUTPUT("DISP(z);");
  GMD_CODE_END();

  CR();CR();
  OUTPUT("The actual screen-shot of the output is shown below:");
  CR();CR();
  OUTPUT("![disp example 1](disp_example1.png)");
  
  // TLDISP()

  GMD_HEADER2("The function `TLDISP(x)`");
  CR();CR();

  OUTPUT("The function `TLDISP(x)` displays the variable type, in addition to the variable name and value");
  CR();CR();
  
  EXAMPLE(Nex++," `TLDISP(x)` usage");

  CR();CR();

  GMD_CODE_START("C++");
  OUTPUT("TLDISP(n);");
  OUTPUT("TLDISP(m);");
  OUTPUT("TLDISP(x);");
  OUTPUT("TLDISP(vals);");
  OUTPUT("TLDISP(done);");
  OUTPUT("TLDISP(v);");
  OUTPUT("TLDISP(str);");
  OUTPUT("TLDISP(s);");
  OUTPUT("TLDISP(z);");
  GMD_CODE_END();

  CR();CR();
  OUTPUT("The actual screen-shot of the output is shown below:");
  CR();CR();
  OUTPUT("![disp example 2](disp_example2.png)");


  // MDISP()

  GMD_HEADER2("The function `MDISP(x1,x2,...)`");
  CR();CR();

  OUTPUT("* The function `MDISP(x1,x2,...)` displays multiple variables (from 1 to 10) on the same line.");
  OUTPUT("* Very useful for displaying:");
  OUTPUT("  * the arguments passed to a function");
  OUTPUT("  * the variables inside a for loop");
  CR();CR();
  

  EXAMPLE(Nex++," `MDISP(x1,x2,...)` usage");
  CR();CR();

  GMD_CODE_START("C++");
  OUTPUT("MDISP(n,m,x,vals,done,str,s,z);");
  GMD_CODE_END();

  CR();CR();
  OUTPUT("The actual screen-shot of the output is shown below:");
  CR();CR();
  OUTPUT("![disp example 3](disp_example3.png)");

  // tried this but doesn't help with displaying at the correct scale
  // the image are always blurred by github for some reason
  //OUTPUT("<img src=\"disp_example3.png\" width=\"100%\" height=\"100%\">");


  // DISPVAL()

  GMD_HEADER2("The function `DISPVAL(x)`");
  CR();CR();

  OUTPUT("* The function `DISPVAL(x)` prints only the variable value, without the name and equals sign, and _without a carriage return_.");
  CR();CR();
  

  EXAMPLE(Nex++," `DISPVAL(x)` usage");
  CR();CR();

  GMD_CODE_START("C++");
  OUTPUT("DISPVAL(n);");
  OUTPUT("DISPVAL(m);");
  GMD_CODE_END();

  CR();CR();
  OUTPUT("The actual screen-shot of the output is shown below:");
  CR();CR();
  OUTPUT("![disp example 3b](disp_example3b.png)");


  // expressions

  GMD_HEADER2("Displaying expressions");
  CR();CR();

  OUTPUT("* The functions introduced above can also be used to display expressions.");
  OUTPUT("* vector and matrix expressions can be displayed in this manner.");
  CR();CR();
  

  EXAMPLE(Nex++," displaying expressions");
  CR();CR();

  GMD_CODE_START("C++");
  OUTPUT("DISP(n+3);");
  OUTPUT("DISP(10*x-1);");
  OUTPUT("DISP(!done);");
  OUTPUT("DISP( round(10*sin(pi/10*v) + 10) );");
  OUTPUT("DISP(s+\" tour\");");
  GMD_CODE_END();

  CR();CR();
  OUTPUT("The actual screen-shot of the output is shown below:");
  CR();CR();
  OUTPUT("![disp example 4](disp_example4.png)");


  // expressions

  GMD_HEADER2("Supported Types");
  CR();CR();

  OUTPUT("The following types are currently supported by the display commands");
  OUTPUT("* **Any class** with methods `.classname()` and `operator<<` is automatically supported");
  OUTPUT("* `mathq::Vector<D>` vectors");
  OUTPUT("* `mathq::Matrix<D>` matrices");
  OUTPUT("* `bool`");
  OUTPUT("* `short`, `int`, `long`, `long long`");
  OUTPUT("* `unsigned short`, `unsigned int`, `unsigned long`, `unsigned long long`");
  OUTPUT("* `float`, `double`, `long double`");
  OUTPUT("* `char`, `unsigned char`");
  OUTPUT("* `char[]` C-style strings");
  OUTPUT("* `D[]` C-style arrays");
  OUTPUT("* `std::string` C++ strings");
  OUTPUT("* `std::complex<D>` complex numbers");
  OUTPUT("* `std::vector` C++ vectors");
  OUTPUT("* `std::valarray` C++ valarrays");
  OUTPUT("* `std::vector` C++ vectors");
  OUTPUT("* `std::list` C++ lists");
  OUTPUT("* `std::queue` C++ queues");
  OUTPUT("* `std::map` C++ maps");
  OUTPUT("* `std::initializer_list` C++11 ");



  // printing to other streams

  GMD_HEADER2("Printing to other streams: `DISP_STRM`, `dispval_strm`, `tdisp_strm`, `mdisp_strm`");
  OUTPUT("* The default stream is `MOUT` (refer to next section)");
  OUTPUT("* You can also utilize all the formatting and color functionality of mathq and print to any output stream you like, including files.  The corresponding functions are shown below.");
  CR();CR();
  OUTPUT("| `MOUT`  | `ostream` |");
  OUTPUT("| ------------- | ------------- |");
  OUTPUT("| `DISPVAL(x)`  | `dispval_strm(ostream,x)`  |");
  OUTPUT("| `DISP(x)`  | `DISP_STRM(ostream,x)`  |");
  OUTPUT("| `TLDISP(x)`  | `TDISP_STRM(ostream,x)`  |");
  OUTPUT("| `MDISP(x,y,...)`  | `MDISP_STRM(ostream,x,y,...)`  |");
  CR();CR();
  

  
  // debug-only printing

  GMD_HEADER2("Debug-only printing");
  CR();CR();

  GMD_HEADER3("Debug-only printing: `disp[123]`, `tdisp[123]`, `mdisp[123]`");
  CR();CR();

  OUTPUT("The display commands also have versions that only display when the code is compiled with the debug flag `MATHQ_DEBUG` set.");
  OUTPUT("* `disp1`, `tdisp1`, `mdisp1` will");
  OUTPUT("  * when `MATHQ_DEBUG >= 1`: behave like `disp`, `tdisp`, `mdisp`");
  OUTPUT("  * when `MATHQ_DEBUG == 0` or is undefined: compile to null statements (ie no output and no real-time hit)");

  OUTPUT("* `disp2`, `tdisp2`, `mdisp2` will");
  OUTPUT("  * when `MATHQ_DEBUG >= 2`: behave like `disp`, `tdisp`, `mdisp`");
  OUTPUT("  * when `MATHQ_DEBUG < 2` or is undefined: compile to null statements (ie no output and no real-time hit)");


  OUTPUT("* `disp3`, `tdisp3`, `mdisp3` will");
  OUTPUT("  * when `MATHQ_DEBUG >= 3`: behave like `disp`, `tdisp`, `mdisp`");
  OUTPUT("  * when `MATHQ_DEBUG < 3` or is undefined: compile to null statements (ie no output and no real-time hit)");


  GMD_HEADER3("Debug-only printing: `print[123]`, `printf[123]`");
  CR();CR();
  
  OUTPUT("* The functions `print1`, `print2`, `print3` each take a single std::string (or C string) as input and print the string to the stream `MOUT` followed by a carriage return.");

  OUTPUT("* The functions `PRINTF1`, `PRINTF2`, `PRINTF3` function like printf, but actually use sprintf and then output to the stream `MOUT` using C++ methodlogy.");


  
  GMD_HEADER2("Changing the mathq output stream and controlling color");
  OUTPUT("* All output uses C++ streams (*no* `printf`)");
  OUTPUT("* By default all output is sent to `std::cout`");
  OUTPUT("* The output stream can be set using `Terminal::setmout(std::ostream&)`.");
  OUTPUT("For example to set the output to stderr:");
  OUTPUT("```C++\n");
  OUTPUT("Terminal::setmout(std::cerr);");
  OUTPUT("```\n");
  OUTPUT("* You can use the mathq output stream via `Terminal::getmout()` or the macro `MOUT`");
  OUTPUT("For example, you can output a string:");
  OUTPUT("```C++\n");
  OUTPUT("MOUT << \"Hello World\" << std::endl;\n");
  OUTPUT("```\n");
  OUTPUT("* By default, mathq uses color when it detects that the output stream is connected to a terminal.");
  OUTPUT("* By default, mathq disables color when it detects that the output stream is piped to a file.");
  OUTPUT("* However, the user can override this behavior as follows\n");
  OUTPUT("To force mathq to use plain text, use the following settings:");
  OUTPUT("```C++\n");
  OUTPUT("Terminal::setColorOverride(true);");
  OUTPUT("Terminal::setOverrideValue(false);");
  OUTPUT("```\n");
  OUTPUT("To force mathq to use color text, use the following settings:");
  OUTPUT("```C++\n");
  OUTPUT("Terminal::setColorOverride(true);");
  OUTPUT("Terminal::setOverrideValue(true);");
  OUTPUT("```\n");
  OUTPUT("This latter setting can be used to print in colors to a file, which will display properly when the file is viewed via a terminal command like `more`,`less`, or `cat`.\n");
  
  CR();CR();
  GMD_HEADER2("The `Style` class");
  OUTPUT("* Color and other text attributes are controlled using the [ANSI escape codes for terminals](https://en.wikipedia.org/wiki/ANSI_escape_code).\n");
  OUTPUT("* mathq defines the class `Style` for applying color and other attributes, such as **bold**\n");
  OUTPUT("* The predefined styles are shown below\n");
  OUTPUT("![styles](displaycolors.png)\n");
  OUTPUT("You can combine the styles using the `+` sign\n");
  OUTPUT("![stylescombined](displaycolorscombined.png)\n");
  OUTPUT("* To use any of these, use the `CREATESTYLE` macro as the following example illustrates");
  OUTPUT("```C++\n");
  OUTPUT("Style mystyle = CREATESTYLE(BOLD+RED);\n");
  OUTPUT("MOUT << mystyle.apply(\"with style\") + \" without style \" << std::endl;\n");
  OUTPUT("```\n");
  OUTPUT("The output from the above two lines of code is:\n");
  OUTPUT("![stylesexample](displaycolorsexample.png)");
  CR();CR();
  OUTPUT("* _The Style class checks to see whether or not to actually use colors, as described in the previous sub-section_\n");
  CR();CR();

  CR();CR();
  GMD_HEADER3("Custom styles");
  OUTPUT("* The user can define a style for any foreground color and background color combination as follows:\n");

  GMD_CODE_START("C++");
  OUTPUT("int nf = 27;  // color for foreground");
  OUTPUT("int nb = 227; // color for background");
  OUTPUT("display::Style mystyle(nf,nb); ");
  OUTPUT("display::MOUT << mystyle.apply(\"Hello World\") << std::endl; ");
  GMD_CODE_END();

  OUTPUT("* Style objects can added:\n");
  GMD_CODE_START("C++");
  OUTPUT("int nf = 27;  // color for foreground");
  OUTPUT("int nb = 227; // color for background");
  OUTPUT("display::Style mystyle(nf,nb);");
  OUTPUT("display::Style bold(BOLD);");
  OUTPUT("display::Style mybold = bold + mystyle;");
  OUTPUT("display::MOUT << mybold.apply(\"Hello World\") << std::endl; ");
  GMD_CODE_END();
  OUTPUT("* Place the attributes, eg `BOLD`, `UNDERLINE`, before the color styles");
  
  OUTPUT("* Wikipedia lists the allowable [8-bit color definitions](https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit)\n");

  
  GMD_HEADER2("Customizing display format for data types");
  CR();CR();
  GMD_HEADER3("Customizing number formats");
  OUTPUT("You can set the number format for any of the primitive datatypes using template function `setFormatString<D>(std::string)`");

  {
    CR();CR();
    EXAMPLE(Nex++," `double` number format");
      
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace display );
    ECHO_CODE( double x = 2.51  );
    GMD_CODE_END();
    OUTPUT("");

    resultstart3(": The default format is `\"%g\"` which yields");
    resultmulti(x );
    resultend();

    GMD_CODE_START("C++");
    ECHO_CODE( setFormatString<double>("%+18.15f")  );
    GMD_CODE_END();
    OUTPUT("");
    resultstart3(": The format `\"%+18.15f\"`  yields");
    resultmulti(x );
    resultend();

  }


  {
    CR();CR();
    EXAMPLE(Nex++," `int` number format");

    GMD_CODE_START("C++");
    ECHO_CODE( using namespace display );
    ECHO_CODE( int n = -1024  );
    GMD_CODE_END();
    OUTPUT("");

    resultstart3(": The default format is `\"%d\"` which yields");
    resultmulti(n);
    resultend();

    GMD_CODE_START("C++");
    ECHO_CODE( setFormatString<int>("%10d")  );
    GMD_CODE_END();
    OUTPUT("");
    resultstart3(": The format `\"%10d\"`  yields");
    resultmulti(n);
    resultend();

  }

  CR();CR();
  GMD_HEADER3("Customizing format for `char`,`string`, and `bool`");
  OUTPUT("* The default format for `char` is `\"%c\"`");
  OUTPUT("* The default format for `std::string` is `\"%s\"`");
  OUTPUT("* For `bool` types, the following _class variables_ are used:");
  OUTPUT("  * `FormatData<bool>::string_for_true`");
  OUTPUT("  * `FormatData<bool>::string_for_false`");
  OUTPUT("* The default `bool` string are `0` and `1`");

  {
    CR();CR();
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace display );
    ECHO_CODE( bool a = true );
    GMD_CODE_END();
    OUTPUT("");

    resultstart3(": The default `bool` format which yields");
    resultmulti(a);
    resultmulti(!a);
    resultend();
    CR();CR();

    OUTPUT("For example, we can change the bool display value to true/false as follows.");
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace display );
    ECHO_CODE( FormatData<bool>::string_for_true = "true" );
    ECHO_CODE( FormatData<bool>::string_for_false = "false" );
    GMD_CODE_END();
    OUTPUT("");

    resultstart3(": The above format yields");
    resultmulti(a);
    resultmulti(!a);
    resultend();
    CR();CR();
  } 


  
  GMD_HEADER3("Customizing complex number format");
  OUTPUT("The format for complex numbers is set using the function `setFormatStringComplex`.  The default format is `\"(%s, %s)\"`\n");
  CR();CR();

  {
    set_default_format();
    EXAMPLE(Nex++," complex number formats");
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace display );
    ECHO_CODE( ComplexDouble z(1,-2)  );
    GMD_CODE_END();
      
    CR();CR();
    OUTPUT("Default format: `\"(%s, %s)\"`\n");
    GMD_CODE_START("C++");
    DISP(z);
    GMD_CODE_END();
      
    CR();CR();
    OUTPUT("Matlab input format `\"%s + i*%s\"`\n");
    setFormatStringComplex("%s + i*%s");
    GMD_CODE_START("C++");
    DISP(z);
    GMD_CODE_END();

    CR();CR();
    OUTPUT("Mathematica input format `\"%s + I*%s\"`\n");
    setFormatStringComplex("%s + I*%s");
    GMD_CODE_START("C++");
    DISP(z);
    GMD_CODE_END();

    CR();CR();
    OUTPUT("Matlab output format / C++14 format `\"%s + %si\"`\n");
    setFormatStringComplex("%s + %si");
    GMD_CODE_START("C++");
    DISP(z);
    GMD_CODE_END();

    CR();CR();
    OUTPUT("Note that the format of the real and imaginary parts of `complex<D>` are controlled by the format string for the template data type.`\n");
    GMD_CODE_START("C++");
    ECHO_CODE( setFormatString<double>("%9.6f")  );
    GMD_CODE_END();
    OUTPUT("The above statement changes the display of `z` to\n");
    GMD_CODE_START("C++");
    DISP(z);
    GMD_CODE_END();

  
  }

  GMD_HEADER3("Customizing Vector format");
  CR();CR();

  OUTPUT("The format for `mathq:Vector` output is controlled by the following static class variables.");
  CR();CR();
  OUTPUT("|`FormatDataVector` class variable|default value|");
  OUTPUT("|------------------|------------------------|");
  OUTPUT("|string_opening| \"{\"|");
  OUTPUT("|string_delimeter | \",\"|");
  OUTPUT("|max_elements_per_line | mathq::maxsize|");
  OUTPUT("|string_endofline | \"\\n\"|");
  OUTPUT("|string_closing |   \"}\"|");
  CR();CR();

  {
    set_default_format();
    EXAMPLE(Nex++," default Vector format");
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace mathq );
    ECHO_CODE( Vector<double> v = range<double>(1001,1010);  );
    GMD_CODE_END();
    OUTPUT("The default format yields\n");
    GMD_CODE_START("C++");
    DISP(v);
    GMD_CODE_END();
  }
  
  GMD_HEADER4("Mathematica-style Vector format");
  CR();CR();
  OUTPUT("The Mathematica-style format allows you to cut and paste results directly into a Mathematica notebook.  ");
  OUTPUT("The function `set_mathematica_var_format()` sets these variables as follows");
  CR();CR();
  OUTPUT("|`FormatDataVector` class variable|Mathematica value|");
  OUTPUT("|------------------|------------------------|");
  OUTPUT("|string_opening| \"{\\n    \" |");
  OUTPUT("|string_delimeter | \", \" |");
  OUTPUT("|max_elements_per_line | 5 |");
  OUTPUT("|string_endofline | \"\\n    \" |");
  OUTPUT("|string_closing |   \"\\n}\"   |");

  CR();CR();
  OUTPUT("* This function also changes the format for doubles and complex numbers");
  CR();CR();
  GMD_CODE_START("C++");
  ECHO_CODE( setFormatString<double>("% 10.8e") );
  ECHO_CODE( FormatData<double>::tens = true );
  ECHO_CODE( setFormatStringComplex("%s + I*%s") );
  GMD_CODE_END();
  {
    
    EXAMPLE(Nex++," Mathematica Vector format");
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace mathq );
    ECHO_CODE( Vector<double> v = range<double>(1001,1010);  );
    ECHO_CODE( set_mathematica_var_format() );
    GMD_CODE_END();
    OUTPUT("The Mathematica format yields\n");
    GMD_CODE_START("C++");
    DISP(v);
    GMD_CODE_END();
  }
  
  GMD_HEADER4("Matlab-style Vector format");
  CR();CR();
  OUTPUT("The Matlab-style format allows you to cut and paste results directly into the Matlab command line or m-file.  ");
  OUTPUT("The function `set_matlab_var_format()` sets these varibles as follows");
  CR();CR();
  OUTPUT("|`FormatDataVector` class variable|Matlab value|");
  OUTPUT("|------------------|------------------------|");
  OUTPUT("|string_opening|   \"[ ...\\n    \"  |");
  OUTPUT("|string_delimeter | \", \"  |");
  OUTPUT("|max_elements_per_line | 5 |");
  OUTPUT("|string_endofline |  \" ...\\n    \"  |");
  OUTPUT("|string_closing |   \" ...\\n]\"  |");

  CR();CR();
  OUTPUT("* This function also changes the format for doubles and complex numbers");
  CR();CR();
  GMD_CODE_START("C++");
  ECHO_CODE( setFormatString<double>("% 10.8e") );
  ECHO_CODE( FormatData<double>::tens = false );
  ECHO_CODE( setFormatStringComplex("%s + i*%s") );
  GMD_CODE_END();
  {
    
    EXAMPLE(Nex++," Matlab Vector format");
    GMD_CODE_START("C++");
    ECHO_CODE( using namespace mathq );
    ECHO_CODE( Vector<double> v = range<double>(1001,1010);  );
    ECHO_CODE( set_matlab_var_format() );
    GMD_CODE_END();
    OUTPUT("The Matlab format yields\n");
    GMD_CODE_START("C++");
    DISP(v);
    GMD_CODE_END();
  }

  GMD_HEADER2("Changing the color and style settings\n");
  OUTPUT("* In addition to the formatting discussed above, each data type has Styles that control the color and text attributes (eg boldness) of output\n");

  GMD_HEADER3("Color and style settings for floating point types\n");

  CR();CR();
  OUTPUT("| `FormatData<D>` class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(MAGENTA) | ");
  OUTPUT("| style_for_value | Style(BLACK) | ");
  OUTPUT("| style_for_zero | Style(GRAY1) | ");
  CR();CR();


  GMD_HEADER3("Color and style settings for signed integer types\n");

  CR();CR();
  OUTPUT("| `FormatData<D>` class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(MAGENTA) | ");
  OUTPUT("| style_for_value | Style(BLUE2) | ");
  OUTPUT("| style_for_zero | Style(GRAY1) | ");
  CR();CR();

  GMD_HEADER3("Color and style settings for unsigned integer types\n");

  CR();CR();
  OUTPUT("| `FormatData<D>` class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(MAGENTA) | ");
  OUTPUT("| style_for_value | Style(VIOLET1) | ");
  OUTPUT("| style_for_zero | Style(GRAY1) | ");
  CR();CR();



  GMD_HEADER3("Color and style settings for `bool`\n");

  CR();CR();
  OUTPUT("| `FormatData<D>` class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(MAGENTA) | ");
  OUTPUT("| style_for_true | Style(GREEN1) | ");
  OUTPUT("| style_for_false | Style(GRAY1) | ");
  CR();CR();

  GMD_HEADER3("Color and style settings for `char`\n");

  CR();CR();
  OUTPUT("| `FormatData<D>` class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(MAGENTA) | ");
  OUTPUT("| style_for_value | Style(BLACK) | ");
  CR();CR();

  GMD_HEADER3("Color and style settings for `string`\n");

  CR();CR();
  OUTPUT("| `FormatData<D>` class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(GREEN) | ");
  OUTPUT("| style_for_value | Style(BLACK) | ");
  CR();CR();

  GMD_HEADER3("Color and style settings for `std::complex`\n");
  CR();CR();
  OUTPUT("| **FormatDataComplex** class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(GREEN) | ");
  OUTPUT("| style_for_punctuation | Style(GRAY1) | ");
  CR();CR();
  
  GMD_HEADER3("Color and style settings for `Vector`\n");
  CR();CR();
  OUTPUT("| **FormatDataVector** class variable | default value | ");
  OUTPUT("|--------------------|----------------------------|");
  OUTPUT("| style_for_type_name | Style(CYAN) | ");
  OUTPUT("| style_for_punctuation | Style(GRAY1) | ");
  CR();CR();

  mathq_toc();

  return 0;
}
